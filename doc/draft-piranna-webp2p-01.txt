INTERNET DRAFT                          Jesús Leganés Combarro "piranna"
Document: draft-piranna-webp2p-01                          (independent)


                                 webp2p

Abstract

    This draft describes a protocol by which two machines can discover
    and interconnect themselves using WebRTC to create a P2P network,
    being able to use for handshaking a third party server independently
    of its protocol or other intermediary peers already connected on the
    network. This protocol is based on public-key encrypted messages and
    allow to do the connections anonymously and at the same time to
    authenticate trusted peers.

Status of this Memo

    This Internet-Draft is work-in-progress.

Copyright Notice

    Copyright (c) 2014 the persons identified as the document authors.
    All rights reserved.

Table of Contents

    1. Introduction....................................................2
    2. Terminology.....................................................2
    3. Cycle of life...................................................3
    4. Messages........................................................3
      4.1 Handshake servers only.......................................4
        4.1.1 Presence.................................................4
          4.1.1.1 Message format.......................................5
      4.2 Connection messages..........................................5
        4.2.1 Encryption scheme........................................7
        4.2.2 Offer....................................................7
          4.2.2.1 Message format.......................................7
        4.2.3 Answer...................................................8
          4.2.3.1 Message format.......................................8
        4.2.4 Error....................................................9
          4.2.4.1 Message format.......................................9
      4.3 Inter-peers only.............................................9
        4.3.1 Authenticate............................................10
          4.3.1.1 Signature scheme....................................10
          4.3.1.2 Message format......................................10
        4.3.2 Candidate...............................................10
          4.3.2.1 Message format......................................10
    5. References.....................................................11
    6. Authors' addresses.............................................11







piranna                                                         [Page 1]

Internet-Draft                   webp2p                    February 2014

1.  Introduction

    This specification describes a protocol to create and interconnect
    several machines on a P2P network using WebRTC DataChannel objects.
    It could also be used over any other bidirectional, message oriented
    and binary capable transport layer like BoSH or as a WebSockets
    sub-protocol. To do the initial bootstrapping of the network it is
    required an external service to connect the peers between them,
    being this protocol agnostic about the mechanism used by it (for
    example a peers's pool or a PubSub system), being the only require
    that it can send anonymous one-to-many messages between the peers.

    The actions the interface exposes are:

        * presence: announce our presence so other older peers can send
          us a request to create a connection. This message is only used
          on handshake servers and it's not required when using other
          intermediary peers for the initial connection handshake.

        * offer: ask to a peer to create a connection. This message has
          the minimal information to create it, if more data is need to
          be exchanged to create the connection as required by the user,
          this will be send later in-wire using 'candidate' messages.

        * answer: response to a previous offer message. As with the
          'offer' message, this one has the minimal information to
          create the connection and if more data is need to be exchanged
          it will be send later in-wire using 'candidate' messages.

        * authenticate: send a signed message so receiver can check if
          it knows and can trust to that peer. This message is send by
          both peers to each other only one time as the first message
          once the connection between them has been established.

        * candidate: message send in-wire to exchange pending data from
          'offer' and 'answer' messages required to establish the
          connection as required by the user.

        * error: response to a previous failed request message, for
          example an 'offer' or a 'candidate' one.

    The exact details of these three actions are described in this
    specification.

2. Terminology

    The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
    "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
    document are to be interpreted as described in RFC 2119 [WORDS].






piranna                                                         [Page 2]

Internet-Draft                   webp2p                    February 2014

    "SHOULD" and "SHOULD NOT" are appropriate when valid exceptions to a
    general requirement are known to exist or appear to exist, and it is
    infeasible or impractical to enumerate all of them.  However, they
    should not be interpreted as permitting implementors to fail to
    implement the general requirement when such failure would result in
    interoperability failure.

    "Handshake server" is a third party service external to the P2P
    network used to help on the initial bootstrapping of the peers. It
    can use any message oriented transport layer that allow one-to-many
    communications in an anonymous way. Examples of this (but not
    limited to) are anonymous XMPP servers, private timelines on
    microblogging sites, or mDNS/ZeroConf, UPnP and PubSub protocols.

    "SessionID" is an unique ID that identify the peer on all the
    network. It correspond to a per-session randomly created public-key,
    but it can also be statically set by the user to be easily
    reacheable. Being a public-key, other peers use it to encrypt the
    messages when sending them to that peer.

    "UserID" is an unique ID that is based on a persistent randomly
    created public-key and so it identify the peer between sessions. It
    is used to authenticate and trust the peer against others, and due
    to this it's never transmitted on the wire.

3. Cycle of life

    

4. Messages

    Communication is message based using a binary format with fixed
    length fields except the last one in some of them (specified later),
    where it's length is correspond to the pending bytes until the end
    of the message. To be able to send them inside a unique IP package
    both using a handshake server or a DataChannel connection, the
    messages max length will not be greater that the [SCTP payload],
    being this of a size of 1192 bytes.

    Communication is done in an asynchronous way, not waiting for a
    response and processing all the messages in the order they are being
    received since these can arrive at any moment.

    Each message is composed by three fields: 'ttl' (Time-to-life) and
    'method' on the first byte of the message using one nibble (4 bits)
    each one, and 'data' using the remaining space:

        * ttl: it uses the high half of the first byte of the message
          and it's stored unsigned. It's used to limit the number of
          retransmissions of a message, and only values greater than
          zero are considered valid ttl values. Zero is a special case
          used to flag messages where the 'data' field is send on clear,
          and due to that they MUST NOT be forwarded, for example
          'presence' or 'candidate' messages.

piranna                                                         [Page 3]

Internet-Draft                   webp2p                    February 2014

        * method: it uses the low half of the first byte of the message
          and it's stored signed. Positive values indicate the function
          associated to the message. Currently they are used from 0 to 4
          ('presence', 'offer', 'answer', 'authenticate' & 'candidate'),
          being the values from 5 to 7 reserved for future use. Negative
          values are used to indicate response error messages.

        * data: it store the per-message specific data. If 'ttl' field
          of the message is different of zero, this data is encrypted
          with the receiver session public-key (SessionID).

4.1. Handshake servers only

            | Presence         |
    |-------|==================|
    | 0     | ttl=0 | method=0 |
    |-------|------------------|
    | 1-256 | from (256)       |
    |-------|==================|

4.1.1. Presence

    Presence message is used to notify our presence when connecting to a
    handshake server so other (older) peers connected to it can send to
    us a connection offer, and due to this it MUST NOT be used when
    using intermediary peers to interconnect two of them already on the
    P2P network. After sending the presence message, the peer keeps
    waiting listening for the arrival of presence messages from new
    peers, choosing to send them a connection offer or not according to
    the number of newer peers it got connected thanks to this handshake
    server. This number is related to each handshake server limits.

    When detecting that a new peer has connected to a handshake server,
    the algorithm to choose if a peer should connect to this new peer or
    not is left to the developer and should adjust it to the limits of
    the particular handshake server used, but the next three algorithms
    are proposed:

        * connect to all newer peers. This allow to quickly increase the
          number of connections with newer peers, but all of them would
          be located in a reduced slice of time.

        * connect randomly: this allow a greater arity distribution of
          the network over time, but would be slower to get a peers
          critic mass on that handshake server and disconnect from it.

        * connect on increasing intervals: increase progressively the
          number of "leap" peers when connecting to them, both randomly
          or numerically. This would spend a lot of time to get the full
          critic mass, but also will assure that we got a big enought
          number of peers just after connecting to the handshake server
          and also distribute them homogeneity.



piranna                                                         [Page 4]

Internet-Draft                   webp2p                    February 2014

    When the peer got connected to that predefined number of newer peers
    (a "critic mass") over a particular handshake server, it disconnect
    itself from it and start using preferentially the P2P network to
    connect to other peers, allowing to other new peers to use the
    handshake server and increasing the network arity.

    After disconnecting from the handshake server, it's left to the
    developer or user decision if the peer should connect to a new
    handshake server (if available) after it gets disconnected from one
    of them or not. Also, it could be defined to connect to several of
    them at the same time. It's recommended that if possible, don't
    disconnect from handshake servers and protocols without usage limits
    like the ones working on a LAN network.

4.1.1.1. Message format

    The message is identified by having zero as 'ttl' as a special value
    (otherwise it is an invalid one) meaning the 'data' field is send on
    clear, the 'method' field set to zero, and the 'data' field length
    equal to the length of a SessionID as a double check, containing in
    that case the SessionID of the the newly connected peer stored in
    raw binary format, and doing the functionality of a 'from' field.
    This field data is later used as a public-key by the other peers to
    encrypt their connection requests in the 'offer' messages.

     * ttl:    [4 bits]    = 0
     * method: [4 bits]    = 0
     * from:   [256 bytes] = sessionID (session public-key)

    Total message size: 1+256 = 257 bytes

4.2. Connection messages

               | Offer          | Answer         | Error          |
    |----------|================|================|================|
    | 0        | ttl | method=1 | ttl | method=2 | ttl | method<0 |
    |----------|================|================|================|
    | 1        | id (1)         | id (1)         | id (1)         |
    |----------|----------------|----------------|----------------|
    | 2-257    | from (256)     | sdp (<=1190)   | data (<=1190)  |
    |----------|----------------|                |                |
    | 258-1191 | sdp (<=934)    |                |                |
    |----------|================|================|================|

    Connection messages are used to establish a new connection between
    two peers and follow a request-response scheme. They can be send
    both through handshake servers or using other intermediary peers,
    so due to that the message 'data' field MUST be send encrypted. The
    connection also creates a WebRTC DataChannel (by default identified
    with the 'webp2p' label) used for signaling between both peers and
    to forward connection messages from other peers over the P2P mesh
    network.



piranna                                                         [Page 5]

Internet-Draft                   webp2p                    February 2014

    Connection messages are designed to fit in a [SCTP payload], being
    this of a size of 1192 bytes, so thay can be send over a single
    WebRTC DataChannel packet. This requires that the messages send
    the minimal necessary info, delegating the non-essential data to
    create the connection to be send later in-wire over the signaling
    DataChannel created between both peers in a 'Trickle-ICE' way. Due
    to this, the 'offer' and 'answer' messages only include on their
    'sdp' field their SDP offer or answer info, and the candidates info
    needed to create the in-wire signaling DataChannel. Other candidates
    can be appended on the 'offer' and 'answer' messages 'sdp' field if
    the total message size is not bigger than the allowed SCTP payload.
    Pending candidates required to finish to establish the connection as
    it was requested by the user MUST be send later using the in-wire
    signaling channel.

    Message 'ttl' field set a limit on the number or retransmissions or
    forwarding of the messages, being 5 (five) the initial max value. It
    MUST be decreased each time a message is forwarded to a consecutive
    peer down to zero, when it's not allowed to continue. Zero 'ttl' is
    a special case to flag that the 'data' field is send in clear, so
    the message MUST not be forwarded since it could have sensitive data
    that can be intercepted by third parties.

    The encryption of the 'data' field is done with the receiver peer
    session public-key (its SessionID) so only it can decipher the
    message. This is done to prevent third-parties to intercept the
    message and access to sensitive data like peers IPs while
    forwarding it.

    Due to their request-response scheme, all the connection messages
    has a message 'id' field inside the encrypted 'data' field. This is
    used to identify the sequence of messages send to another particular
    peer and correlate with their response when it's received. Each
    sequence of send messages IDs is unique for each one of the peers to
    whom the sender is connected so its size can be smaller. If one of
    message IDs counter reach the maximum value that this field can host
    it will start over from the beginning.

    When a connection message reaches a peer, this one checks if it's
    the receiver by trying to decrypt the message 'data' field with its
    session private-key. In case it was not possible, it assume was not
    the receiver of the message and forward it.

    To forward a message, the peer first decreases the message 'ttl'
    field and if it's zero then the message is discarded by reaching the
    max TTL value. If not, then it sends the message to all the peers
    and handshake servers it is connected except the one where it
    received the message to prevent loops. It's RECOMMENDED that the
    peer store the messages for one or two minutes to check new ones
    against them and discard messages already forwarded.





piranna                                                         [Page 6]

Internet-Draft                   webp2p                    February 2014

4.2.1 Encryption scheme

    Sessions made use of RSA 2048, leading to a length of SessionID
    fields of 256 bytes.



4.2.2. Offer

    Offer message is used to request a connection with another peer,
    both using a handshake server or over the P2P network using other
    intermediary peers, maybe by initiative of the user application, or
    in the case of offer messages send over a handshake server, they can
    also be send after receiving a 'presence' message send by another
    newly connected peer.

    After checking that we don't really have a connection to that peer,
    in case the connection is for a new peer connected to a handshake
    server (a response to a 'presence' message) it is send directly over
    the handshake server connection where we got notified about it. In
    case that's a connection initiated by the application, the 'offer'
    message is send broadcasted over all the current connections.

    When the 'offer' message reaches the desired peer, this peer checks
    the 'from' field to see if it has already a connection with that
    peer (so it can discard the message, probably a duplicated one), or
    if it has already send a connection request to the sender. In that
    case, the peer compare its sessionID with the one of the message
    sender to process just one of the two connection requests, having
    preference the one initiated by the peer with lower sessionID. If
    it's the own peer, then the connection request message is discarded
    in benefict of the connection request that it send before; if the
    lower sessionID is the one from the sender, then our previous
    connection request gets aborted and it process to create the
    response message for the received connection request.

    It the peer accepted the incoming connection request, then the peer
    proccess the data on the 'sdp' field to finish the establishment of
    the connection and the in-wire signaling channel between both peers,
    send an 'answer' message to the requester peer with the SDP answer
    and the info to establish the in-wire signaling channel, and wait
    until it is open to send the 'authentication' message and the
    remaining candidates on 'candidate' messages to finish to set the
    connection as the user configured it.

4.2.2.1. Message format

    The message has a 'ttl' field no bigger than its initial max value
    (defined as 5 by this spec), or equal to 1 if the offer is send due
    to a 'presence' message to prevent it being forwarded outside the
    handshake channel where it was send, and it is identified by a
    'method' field with a value of 1.



piranna                                                         [Page 7]

Internet-Draft                   webp2p                    February 2014

    In the encrypted 'data' field, there's a message 'id' field between
    0 and 255 used to identify the message responses. There's also a
    'from' field with the sender session public-key (its sessionID) so
    the receiver of the 'offer' message can be able to identify who is
    sending the connection request so it can send its response, and also
    to encrypt the 'answer' or 'error' response message so only the
    connection request sender can be able to receive the response.
    Finally, the message 'data' field has a variable length 'sdp' field
    storing the offer [SDP] with the minimal required info to establish
    the connection and the connection in-wire signaling channel, that
    fills the remaining message length.

     * ttl:    [4 bits] = 5..1 (1 as response to 'presence' messages)
     * method: [4 bits] = 1

     Encrypted data field:
     * id:   [1 byte]      = 0..255
     * from: [256 bytes]   = sessionID (session public-key)
     * sdp:  [<=934 bytes] = SDP offer & signaling channel candidates

    Total message size: 1+1+256+sdp = 258+sdp bytes

4.2.3. Answer

    Answer messages are send back to the requester peer as response to
    a previous connection requests so the connection can be established
    between both peers.

    When the 'answer' message reaches the requester peer, it checks the
    'id' field and try to link the 'answer' message with a previous
    connection request. In case that was not possible (due to an already
    processed connection so this message is a duplicated one, or because
    the user cancelled the connection request) then this message is
    discarded. In case there was a connection request for this 'answer'
    message, then the peer proccess the data on the 'sdp' field to
    finish the establishment of the connection and the in-wire signaling
    channel between both peers, and wait until it is open to send the
    'authentication' message and the remaining candidates on 'candidate'
    messages to finish to set the connection as the user configured it.

4.2.3.1. Message format

    The message has a 'ttl' field no bigger than its initial max value
    (defined as 5 by this spec), and it is identified by a 'method'
    field with a value of 2.

    In the encrypted 'data' field, there's a message 'id' field between
    0 and 255 equal to the message 'id' of the request offer. Finally,
    it has a variable length 'sdp' field storing the answer [SDP] with
    the minimal required info to establish the connection and the
    connection in-wire signaling channel, that fills the remaining
    message length.



piranna                                                         [Page 8]

Internet-Draft                   webp2p                    February 2014

     * ttl:    [4 bits] = 5..1
     * method: [4 bits] = 2

     Encrypted data field:
     * id:  [1 byte]       = 0..255 (same of the 'offer' message)
     * sdp: [<=1190 bytes] = SDP answer & signaling channel candidates

    Total message size: 1+1+sdp = 2+sdp bytes

4.2.4. Error

    Error messages are send when it was not possible to process a
    request, for example because we have already one open. Specific
    error messages are left for a future revision of this specification.

4.2.4.1. Message format

    Error messages format is equal to the 'answer' messages one, being
    the only differences the 'method' field with a specific value for
    each kind of error, and having a 'data' field instead of a 'sdp'
    field.

    Errors are identified by using negative values for each kind of
    error on the 'method' field. Format of the 'data' field is
    specific for each kind of error.

     * ttl:    [4 bits] = 5..1
     * method: [4 bits] = 0x8..0xF

     Encrypted data field:
     * id:   [1 byte]       = 0..255 (same of the 'offer' message)
     * data: [<=1190 bytes] = error specific data

    Total message size: 1+1+data = 2+data bytes

4.3. Inter-peers only

               | Authenticate     | Candidate        |
    |----------|==================|==================|
    | 0        | ttl=0 | method=3 | ttl=0 | method=4 |
    |----------|------------------|------------------|
    | 1-256    | signature (256)  | sdp (<=1191)     |
    |----------|==================|                  |
    | 257-1191 |                  |                  |
    |----------|                  |==================|

    Inter-peer messages are used to finish to establish the connection
    between two peers. They are send using encrypted direct connections
    between both peers, for example using WebRTC DataChannels, being
    each one the only receiver of the messages send by the other peer.
    Due to this, messages doesn't need to have encrypted data and MUST
    NOT be forwarded.



piranna                                                         [Page 9]

Internet-Draft                   webp2p                    February 2014

4.3.1. Authenticate

    Authenticate messages are used so a peer can confirm its identity to
    the other peer, so this last one can decide if it can trust on this
    peer or not. It's send only one time as the first message after
    establishing a basic connection

    After authenticating (or not) the peer, it's up to the application
    how to proceed. For example, it can be able to enable extra
    functionality with that peer (probably related to exchange of
    sensitive data), or maybe plainly close the connection if the
    authentication of the peer was unsuccessful.

4.3.1.1. Signature scheme

    The signature scheme is inspired on [Digest access authentication].
    The 'signature' message field hold the signature of the previously
    send SDP offer or answer (depending if the peer was the requester or
    the receiver of the request, respectively). This signature is done
    using the peer's user private-key, so the receiver peer can check it
    against a collection of user public-keys (userIDs) that have been
    registered previously.

4.3.1.2. Message format

    The message has a 'ttl' field equal to zero (0) as a flag to
    indicate it MUST NOT be forwarded, a 'method' field equal to three
    (3), and a 'signature' field holding the signature to be checked.

     * ttl:       [4 bits]    = 0
     * method:    [4 bits]    = 3
     * signature: [256 bytes] = timestamp signed with userID private-key

    Total message size: 1+256 = 257 bytes

4.3.2. Candidate

    

4.3.2.1. Message format

    

     * ttl:    [4 bits]       = 0
     * method: [4 bits]       = 4
     * sdp:    [<=1191 bytes] = signaling channel candidates

    Total message size: 1+sdp bytes







piranna                                                        [Page 10]

Internet-Draft                   webp2p                    February 2014

5. References

    [Digest access authentication]
        http://tools.ietf.org/html/rfc2617

    [SCTP payload]
        https://groups.google.com/d/msg/discuss-webrtc/LZsm-jbP0zA/Tim9ODhWsI8J

    [WORDS]
        Bradner, S., "Key words for use in RFCs to Indicate Requirement
        Levels", BCP 14, RFC 2119, March 1997.

6. Authors' addresses

    Jesús Leganés Combarro "piranna"
    (independent)

    Email: piranna@gmail.com





































piranna                                                        [Page 11]
