{"version":3,"file":"bundle.js","sources":["../lib/MessagePacker.js","../lib/PeerConnection_channels.shim.js","../lib/connectors/PubNub.js","../lib/connectors/core/Connector.js","../lib/connectors/core/DataChannel.js","../lib/connectors/core/HandshakeConnector.js","../lib/errors.js","../lib/index.js","../lib/managers/HandshakeManager.js","../lib/managers/Manager.js","../lib/managers/PeersManager.js","../node_modules/browserify/node_modules/events/events.js"],"names":["MessagePacker","sessionID","requestID","this","pack","unpack","message","result","PRESENCE","type","OFFER","ANSWER","error","Error","from","dest","id","ttl","sdp","presence","offer","MAX_TTL_DEFAULT","answer","Manager","MAX_ALLOWED_ERROR_TRIES","BASE_TIMEOUT","module","exports","applyChannelsShim","pc","initChannel","channel","createdbyus","channels","push","addEventListener","splice","indexOf","undefined","getDataChannels","dispatchEvent","event","call","createDataChannel","label","dataChannelDict","Event","Connector_PubNub","config_init","config_mess","HandshakeConnector","self","pubnub","PUBNUB","init","subscribe","connect","_open","_message","disconnect","_close","_error","close","unsubscribe","send","publish","require","prototype","__proto__","constructor","max_connections","max_chars","Connector","EventEmitter","emit","TypeError","Connector_DataChannel","datachannel","JSON","parse","data","stringify","shouldConnect","connections","increaseConnections","Number","POSITIVE_INFINITY","ERROR_NETWORK_UNKNOWN","msg","ERROR_NETWORK_OFFLINE","ERROR_REQUEST_FAILURE","ERROR_REQUEST_EMPTY","ERROR_NO_PEERS","WebP2P","options","onerror","createPeerConnection","callbackType","callback","RTCPeerConnection","iceServers","url","stun_server","optional","DtlsSrtpKeyAgreement","routingLabel","candidate","localDescription","console","peersManager","add","initPeerConnection_Offer","i","commonLabels","mediaConstraints","mandatory","OfferToReceiveAudio","OfferToReceiveVideo","createOffer","setLocalDescription","log","initPeerConnection_Answer","setRemoteDescription","RTCSessionDescription","createAnswer","forward","connector","warning","min","messagepacker","peer","_connectors","handshakeManager","initManagerEvents","manager","on","status","get","UUIDv4","b","a","Math","random","toString","replace","handshake_servers","Object","defineProperty","value","HandshakeManager","PeersManager","__defineGetter__","connectTo","labels","window","createConnector","config","connectorConstructor","handshakeConnectorsConstructors","_initConnector","_messageUnpacked","handshake","configs","length","index","handshakeConnectorConstructors","registerConnectorConstructor","configs_infinity","addConfigs_byObject","addConfigs_byArray","configuration","addConfigs_byUri","json_uri","dispatchError","http_request","XMLHttpRequest","open","onload","response","errors","navigator","onLine","addConfigs","Array","incomingConnector","peers","peerConnection","signalingState","_events","_maxListeners","isFunction","arg","isNumber","isObject","isUndefined","defaultMaxListeners","setMaxListeners","n","isNaN","er","handler","len","args","listeners","arguments","apply","slice","addListener","listener","m","newListener","warned","trace","once","g","removeListener","fired","list","position","removeAllListeners","key","ret","listenerCount","emitter"],"mappings":"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","sourcesContent":["/**\n * Based on code from RPC-Builder\n */\n\n\nconst PRESENCE = 0;\nconst OFFER    = 1;\nconst ANSWER   = 2;\n\nvar MAX_TTL_DEFAULT = 5;\n\nManager.MAX_ALLOWED_ERROR_TRIES = 3;\nManager.BASE_TIMEOUT = 5000;\n\n\nfunction MessagePacker(sessionID)\n{\n  var requestID = 0;\n\n  var requests  = {};\n  var responses = {};\n\n\n  this.pack = function()\n  {\n      \n  };\n\n  this.unpack = function(message)\n  {\n    var result = {};\n\n    // Type\n    switch(message[0])\n    {\n      case PRESENCE:\n        result.type = \"presence\";\n      break;\n\n      case OFFER:\n        result.type = \"offer\";\n      break;\n\n      case ANSWER:\n        result.type = \"answer\";\n      break;\n\n      default:\n      {\n        var error = Error(\"Unknown message type '\"+type+\"'\");\n            error.message = message;\n\n        throw error;\n      };\n    };\n\n    // From\n    result.from = message[1];\n\n    // Offer & Answer\n\n    if(result.type != 'presence')\n    {\n      result.dest = message[2];\n      result.id   = message[3];\n      result.ttl  = message[4];\n      result.sdp  = message[5];\n    };\n\n    return result;\n  };\n\n\n  this.presence = function()\n  {\n    var message =\n    [\n      PRESENCE,  // type\n      sessionID  // from\n    ];\n\n    return message;\n  };\n\n  this.offer = function(dest, sdp)\n  {\n    var message =\n    [\n      OFFER,            // type\n      sessionID,        // from\n      dest,             // dest\n      requestID++,      // id\n      MAX_TTL_DEFAULT,  // ttl\n      sdp               // sdp\n    ];\n\n    return message;\n  };\n\n  this.answer = function(dest, id, sdp)\n  {\n    var message =\n    [\n      ANSWER,           // type\n      sessionID,        // from\n      dest,             // dest\n      id,               // id\n      MAX_TTL_DEFAULT,  // ttl\n      sdp               // sdp\n    ];\n\n    return message;\n  };\n};\n\n\nmodule.exports = MessagePacker;","/**\n * Add support to get a list of channels on a PeerConnection object\n */\nfunction applyChannelsShim(pc)\n{\n  if(pc.getDataChannels != undefined) return;\n\n  var channels = [];\n\n  pc.getDataChannels = function()\n  {\n    return channels;\n  };\n\n  function initChannel(channel, createdbyus)\n  {\n    channel.createdbyus = createdbyus;\n\n    channels.push(channel);\n\n    channel.addEventListener('close', function(event)\n    {\n      channels.splice(channels.indexOf(channel), 1);\n    });\n  };\n\n  // Add DataChannels created by remote PeerConnection object\n  var dispatchEvent = pc.dispatchEvent;\n  pc.dispatchEvent = function(event)\n  {\n    if(event.type == 'datachannel')\n    {\n      var channel = event.channel;\n\n      initChannel(channel, false);\n    };\n\n    // Dispatch events\n    dispatchEvent.call(this, event);\n  };\n\n  // Add DataChannels created by local PeerConnection object\n  var createDataChannel = pc.createDataChannel;\n  pc.createDataChannel = function(label, dataChannelDict)\n  {\n    var channel = createDataChannel.call(this, label, dataChannelDict);\n\n    initChannel(channel, true);\n\n    // Dispatch datachannel events for local created ones\n    var event = new Event('datachannel');\n        event.channel = channel;\n\n    dispatchEvent.call(this, event);\n  };\n};\n\n\nmodule.exports = applyChannelsShim;","var HandshakeConnector = require(\"./core/HandshakeConnector\");\n\n\n/**\n * Handshake connector for PubNub\n * @param {Object} configuration Configuration object.\n */\nfunction Connector_PubNub(config_init, config_mess)\n{\n  HandshakeConnector.call(this);\n\n  var self = this;\n\n  var channel = config_mess.channel;\n\n\n  // Connect a handshake connector to the PubNub server\n  var pubnub = PUBNUB.init(config_init);\n\n  // Configure handshake connector\n  pubnub.subscribe(\n  {\n    channel: channel,\n\n    connect:    self._open,\n    message:    self._message,\n    disconnect: self._close,\n    error:      self._error\n  });\n\n\n  // Define methods\n\n  /**\n   * Close the connection with this handshake server\n   */\n  this.close = function()\n  {\n    pubnub.unsubscribe(\n    {\n      channel: channel\n    });\n\n//    self._close();\n  }\n\n  /**\n   * Send the message\n   */\n  this.send = function(message)\n  {\n    pubnub.publish(\n    {\n      channel: channel,\n      message: message\n    });\n  };\n}\nConnector_PubNub.prototype.__proto__   = HandshakeConnector.prototype;\nConnector_PubNub.prototype.constructor = Connector_PubNub;\n\n//Class constants\nConnector_PubNub.prototype.max_connections = 50;\nConnector_PubNub.prototype.max_chars       = 1800;\n\n\nmodule.exports = Connector_PubNub;","var EventEmitter = require(\"events\").EventEmitter;\n\n\nfunction Connector()\n{\n  EventEmitter.call(this);\n\n  var self = this;\n\n\n  /**\n   * Notify that the connection to this handshake server is open\n   */\n  this._open = function()\n  {\n    self.emit('open');\n  };\n\n  this._message = function(message)\n  {\n    self.emit(\"message\", message);\n  };\n\n  this._close = function()\n  {\n    self.emit('close');\n  };\n\n  this._error = function(error)\n  {\n    self.emit('error', error);\n  };\n};\nConnector.prototype.__proto__   = EventEmitter.prototype;\nConnector.prototype.constructor = Connector;\n\nConnector.prototype.close = function()\n{\n  throw new TypeError(\"Connector.close should be defined in a child class\");\n};\nConnector.prototype.send = function(message)\n{\n  throw new TypeError(\"Connector.send should be defined in a child class\");\n};\n\n\nmodule.exports = Connector;","var Connector = require(\"./Connector\");\n\n\nfunction Connector_DataChannel(datachannel)\n{\n  Connector.call(this);\n\n  var self = this;\n\n\n  datachannel.addEventListener('open',  self._open);\n  datachannel.addEventListener('message', function(event)\n  {\n    self._message(JSON.parse(event.data));\n  });\n  datachannel.addEventListener('close', self._close);\n  datachannel.addEventListener('error', self._error);\n\n\n  // Define methods\n\n  /**\n   * Close the connection with the peer\n   */\n  this.close = function()\n  {\n    datachannel.close();\n  };\n\n  /**\n   * Send the message\n   */\n  this.send = function(message)\n  {\n    datachannel.send(JSON.stringify(message));\n  };\n};\nConnector_DataChannel.prototype.__proto__   = Connector.prototype;\nConnector_DataChannel.prototype.constructor = Connector_DataChannel;\n\n\nmodule.exports = Connector_DataChannel;","var Connector = require(\"./Connector\");\n\n\nfunction HandshakeConnector()\n{\n  Connector.call(this);\n\n  var self = this;\n\n\n  /**\n   * Check if we should connect this new peer or ignore it to increase entropy\n   * in the network mesh\n   *\n   * @returns {Boolean}\n   */\n  this.shouldConnect = function()\n  {\n    return true;\n  };\n\n\n  // Count the maximum number of pending connections allowed to be\n  // done with this handshake server (undefined == unlimited)\n  var connections = 0;\n\n  this.increaseConnections = function()\n  {\n    // Increase the number of connections reached throught\n    // this handshake server\n    connections++;\n\n    // Close connection with handshake server if we got its quota of peers\n    if(connections >= self.max_connections)\n       self.close();\n  };\n};\nHandshakeConnector.prototype.__proto__   = Connector.prototype;\nHandshakeConnector.prototype.constructor = HandshakeConnector;\n\n// Class constants\nHandshakeConnector.prototype.max_connections = Number.POSITIVE_INFINITY;\n\n\nmodule.exports = HandshakeConnector;","const ERROR_NETWORK_UNKNOWN = {id: 0, msg: 'Unable to fetch handshake servers configuration'};\nconst ERROR_NETWORK_OFFLINE = {id: 1, msg: \"There's no available network\"};\nconst ERROR_REQUEST_FAILURE = {id: 2, msg: 'Unable to fetch handshake servers configuration'};\nconst ERROR_REQUEST_EMPTY   = {id: 3, msg: 'Handshake servers configuration is empty'};\n\nconst ERROR_NO_PEERS        = {id: 4, msg: 'Not connected to any peer'};\n\n\nexports.ERROR_NETWORK_UNKNOWN = ERROR_NETWORK_UNKNOWN;\nexports.ERROR_NETWORK_OFFLINE = ERROR_NETWORK_OFFLINE;\nexports.ERROR_REQUEST_FAILURE = ERROR_REQUEST_FAILURE;\nexports.ERROR_REQUEST_EMPTY   = ERROR_REQUEST_EMPTY;\nexports.ERROR_NO_PEERS        = ERROR_NO_PEERS;","var EventEmitter = require(\"events\").EventEmitter;\n\n//var uuid = require('uuid');\n\nvar HandshakeManager = require('./managers/HandshakeManager');\nvar PeersManager     = require('./managers/PeersManager');\n\nvar MessagePacker = require('./MessagePacker');\n\nvar applyChannelsShim = require(\"./PeerConnection_channels.shim\");\n\n\n/**\n * @classdesc Init and connect to the WebP2P.io network\n *\n * @constructor\n */\nfunction WebP2P(options)\n{\n  var self = this;\n\n\n  /**\n   * UUID generator\n   */\n  var UUIDv4 = function b(a)\n  {\n    return a ? (a ^ Math.random() * 16 >> a / 4).toString(16) : ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, b);\n  };\n\n\n  var options = options || {};\n\n  // Internal options\n  var commonLabels      = options.commonLabels || [];\n  var handshake_servers = options.handshake_servers;\n  var stun_server       = options.stun_server || 'stun.l.google.com:19302';\n\n  // Read-only options\n  Object.defineProperty(this, \"routingLabel\",\n  {\n    value: options.routingLabel || \"webp2p\"\n  });\n  Object.defineProperty(this, \"sessionID\",\n  {\n    value: options.sessionID || UUIDv4()\n//    value: options.sessionID || uuid.v4()\n  });\n\n\n  var messagePacker = new MessagePacker(this.sessionID);\n\n  var handshakeManager = new HandshakeManager(handshake_servers, messagepacker);\n  var peersManager     = new PeersManager(self.routingLabel);\n\n  this.__defineGetter__(\"status\", function()\n  {\n    if(peersManager.status == 'connected')\n      return 'connected'\n\n    return handshakeManager.status\n  });\n\n\n  function onerror(error)\n  {\n    self.emit('error', error);\n  };\n\n\n  /**\n   * Create a new RTCPeerConnection\n   * @param {UUID} id Identifier of the other peer so later can be accessed.\n   *\n   * @return {RTCPeerConnection}\n   */\n  function createPeerConnection(sessionID, callbackType, callback)\n  {\n    var pc = new RTCPeerConnection\n    (\n      {iceServers: [{url: 'stun:'+stun_server}]},\n      {optional: [{DtlsSrtpKeyAgreement: true}]}\n    );\n\n    applyChannelsShim(pc);\n\n    self.emit('peerconnection', pc);\n\n    pc.createDataChannel(self.routingLabel);\n\n    pc.addEventListener('icecandidate', function(event)\n    {\n      // There's a candidate, ignore it\n      if(event.candidate)\n        return;\n\n      // There's no candidate, send the full SDP\n      var type = this.localDescription.type;\n      var sdp  = this.localDescription.sdp;\n\n      if(type == callbackType)\n        callback(sdp)\n      else\n        console.error(type+\" SDP type is not equal to \"+callbackType+\" callback type\");\n    });\n\n    // Add PeerConnection object to available ones when gets open\n    pc.addEventListener('open', function(event)\n    {\n      peersManager.add(sessionID, pc);\n    });\n\n    return pc;\n  };\n\n\n  function initPeerConnection_Offer(pc, labels)\n  {\n    // Set channels for this PeerConnection object\n    for(var i=0, label; label=commonLabels[i]; i++)\n      pc.createDataChannel(label);\n\n    // Send offer\n    var mediaConstraints =\n    {\n      mandatory:\n      {\n        OfferToReceiveAudio: false,\n        OfferToReceiveVideo: false\n      }\n    };\n\n    pc.createOffer(function(offer)\n    {\n      // Set the peer local description\n      pc.setLocalDescription(offer,\n      function()\n      {\n        console.log(\"LocalDescription correctly set for \"+from);\n      },\n      onerror);\n    },\n    onerror,\n    mediaConstraints);\n  };\n\n  function initPeerConnection_Answer(pc)\n  {\n    // Process offer\n    pc.setRemoteDescription(new RTCSessionDescription(\n    {\n      sdp: message.sdp,\n      type: 'offer'\n    }),\n    function()\n    {\n      // Send answer\n      pc.createAnswer(function(answer)\n      {\n        // Set the peer local description\n        pc.setLocalDescription(answer,\n        function()\n        {\n          console.log(\"Generated Answer LocalDescription for \"+from);\n        },\n        onerror);\n      },\n      onerror)\n    },\n    onerror);\n  };\n\n\n  //\n  // Connection methods\n  //\n\n  /**\n   * Callback to send the offer. If not defined send it to all connected peers.\n   *\n   * @callback WebP2P~ConnectToCallback\n   * @param {Error} error\n   * @param {RTCPeerConnection} peer - The (newly created) peer\n   */\n\n  /**\n   * Connects to another peer based on its UID. If we are already connected,\n   * it does nothing.\n   *\n   * @param {UUID} sessionID - Identifier of the other peer to be connected.\n   * @param {string[]} [labels] - Per-connection labels\n   * @param {WebP2P~ConnectToCallback} callback\n   */\n  this.connectTo = function(dest, labels, callback)\n  {\n    var peer = peersManager.get(dest);\n    if(peer)\n      callback(null, peer)\n\n    else\n    {\n      peer = createPeerConnection(dest, \"offer\", function(offer)\n      {\n        var message = messagepacker.offer(dest, offer, callback);\n\n        handshakeManager.send(message);\n        peersManager.send(message);\n      });\n\n      initPeerConnection_Offer(peer, labels);\n    }\n  };\n\n\n  //\n  // Managers\n  //\n\n  function forward(message, connector)\n  {\n    // Don't forward the message if TTL has been achieved\n    if(--message.ttl <= 0)\n    {\n      console.warning(\"TTL achieved: \"+message);\n      return;\n    };\n\n    // Ensure that TTL is not over the maximum\n    message.ttl = min(message.ttl, MAX_TTL_DEFAULT);\n\n    var dest = message.dest;\n\n    message = messagepacker.pack(message);\n\n    // Search the peer between the ones currently connected\n    for(var i=0, peer; peer=peersManager._connectors[i]; i++)\n      if(peer.sessionID === dest)\n      {\n        peer.send(message);\n        return;\n      };\n\n    // Peer was not found, forward message to all the connectors\n    peersManager.send(message, connector);\n    handshakeManager.send(message, connector);\n  };\n\n\n  function initManagerEvents(manager)\n  {\n    //\n    // Basic events\n    //\n\n    manager.on('connected', function(connector)\n    {\n      if(handshakeManager.status != peersManager.status)\n        self.emit('connected');\n    });\n    manager.on('disconnected', function()\n    {\n      if(handshakeManager.status == peersManager.status)\n        self.emit('disconnected');\n    });\n    manager.on('error', function(error)\n    {\n      self.emit('error', error);\n    });\n\n    //\n    // Offer & answer events\n    //\n\n    manager.on('offer', function(message, connector)\n    {\n      var from = message.from;\n      var dest = message.dest;\n\n      console.log(\"Received connection request from \"+from);\n\n      // Message is for us\n      if(dest == sessionID)\n      {\n        // Search the peer between the list of currently connected ones,\n        // or create it if it's not connected\n        var pc = createPeerConnection(from, \"answer\", function(answer)\n        {\n          var message = messagepacker.answer(from, message.id, answer);\n\n          // Send back the connection request over the same connector, since\n          // this should be the shortest path to connect both peers\n          connector.send(message);\n        });\n\n        initPeerConnection_Answer(pc);\n      }\n\n      // Forward message\n      else\n        forward(message, connector);\n    });\n\n    manager.on('answer', function(message, connector)\n    {\n      var from = message.from;\n      var dest = message.dest;\n\n      // Message is for us\n      if(dest == sessionID)\n      {\n        console.log(\"Received connection response from \"+from);\n\n        var peer = peersManager.get(from);\n        if(peer)\n        {\n          peer.setRemoteDescription(new RTCSessionDescription(\n          {\n            sdp: sdp,\n            type: 'answer'\n          }),\n          function()\n          {\n            console.log(\"Successfuly generated RemoteDescription for \"+from);\n          },\n          onerror);\n\n          connector.increaseConnections();\n        }\n        else\n          onerror(\"Connection with peer '\" + from + \"' was not previously requested\");\n      }\n\n      // Forward message\n      else\n        forward(message, connector);\n    });\n  };\n\n  // Init managers events\n\n  initManagerEvents(handshakeManager);\n  initManagerEvents(peersManager);\n\n  handshakeManager.on('presence', function(from, connector)\n  {\n    var peer = peersManager.get(from);\n    if(!peer)\n    {\n      var pc = createPeerConnection(from, \"offer\", function(offer)\n      {\n        var message = messagepacker.offer(from, offer);\n\n        // Send back the connection request over the same connector, since this\n        // should be the shortest path to connect both peers\n        connector.send(message);\n      });\n\n      initPeerConnection_Offer(pc, labels);\n    }\n  });\n\n\n  //\n  // Clossing functions\n  //\n\n  this.close = function()\n  {\n    handshakeManager.close();\n    peersManager.close();\n  };\n\n  // Close all connections when user goes out of the page\n  if(window)\n    window.addEventListener('beforeunload', function(event)\n    {\n      self.close();\n    });\n};\nWebP2P.prototype.__proto__   = EventEmitter.prototype;\nWebP2P.prototype.constructor = WebP2P;\n\n\nexports.WebP2P = WebP2P;","var Manager = require('./Manager');\n\nvar errors = require('../errors');\n\n\nvar Connector_PubNub = require('../connectors/PubNub');\n\n\n/**\n * Manage the handshake connectors using several servers\n *\n * @constructor\n * @param {String} json_uri URI of the handshake servers configuration.\n */\nfunction HandshakeManager(handshake_servers, messagepacker)\n{\n  Manager.call(this);\n\n  var self = this;\n\n\n  var handshakeConnectorConstructors = {};\n\n  this.registerConnectorConstructor = function(type, constructor)\n  {\n    handshakeConnectorConstructors[type] = constructor\n  };\n\n\n  // Default handshake connectors\n  this.registerConnectorConstructor('PubNub', Connector_PubNub);\n\n\n  function createConnector(config)\n  {\n    var type        = config.type;\n    var config_init = config.config_init;\n    var config_mess = config.config_mess;\n\n    // Check if connector constructor is from a valid handshake server\n    var connectorConstructor = handshakeConnectorsConstructors[type];\n    if(!connectorConstructor)\n      throw Error(\"Invalid handshake server type '\" + type + \"'\");\n\n    var connector = new connectorConstructor(config_init, config_mess);\n\n    self._initConnector(connector);\n\n    connector.on('open', function()\n    {\n      // Notify our presence to the other peers\n      connector.send(messagepacker.presence());\n    });\n\n    connector._messageUnpacked = function(message)\n    {\n      if(message.type == 'presence')\n      {\n        if(connector.shouldConnect())\n          self.emit(\"presence\", message.from, connector);\n      }\n      else\n        Manager._messageUnpacked.call(this, message);\n    };\n\n    return connector;\n  };\n\n\n  var configs = [];\n  var index = 0;\n\n  var configs_infinity = [];\n\n  /**\n   * Get a random handshake connector or test for the next one\n   * @param {Object} configuration Handshake servers configuration.\n   */\n  function handshake()\n  {\n    if(!configs.length)\n      throw Error('No handshake servers defined')\n\n    for(; index < configs.length; index++)\n    {\n      var connector = createConnector(configs[index]);\n      if(connector)\n      {\n        connector.on('close', function()\n        {\n          // Handshake connector has been closed, try to get an alternative one\n          index++;\n          handshake();\n        });\n\n        // Connector successfully created\n        return;\n      };\n    };\n\n    // All configured handshake servers has been consumed\n    // Get ready to start again from beginning of handshake servers list\n    index = 0;\n\n    // There are no more available configured handshake servers\n    if(self.status == 'disconnected')\n       self.emit('disconnected');\n  };\n\n\n  this.addConfigs_byObject = function(config)\n  {\n    // Check if connector constructor is from a valid handshake server\n    var connectorConstructor = handshakeConnectorsConstructors[type];\n    if(!connectorConstructor)\n    {\n      console.error(\"Invalid handshake server config: \"+config);\n      return;\n    };\n\n    if(connectorConstructor.prototype.max_connections == Number.POSITIVE_INFINITY)\n    {\n      configs_infinity.push(config)\n\n      // Start handshaking\n      var connector = createConnector(config);\n      connector.on('close', function()\n      {\n        if(self.status == 'disconnected')\n           self.emit('disconnected');\n      });\n    }\n    else\n    {\n      configs.push(config);\n\n      // Start handshaking\n      if(self.status == 'disconnected')\n      {\n        if(index == undefined)\n           index = 0;\n\n        handshake();\n      }\n    }\n  };\n\n  this.addConfigs_byArray = function(configuration)\n  {\n    for(var i=0, config; config=configuration[i]; i++)\n      self.addConfigs_byObject(config);\n  };\n\n  this.addConfigs_byUri = function(json_uri)\n  {\n    function dispatchError(error)\n    {\n      self.emit('error', error);\n    };\n\n    // Request the handshake servers configuration file\n    var http_request = new XMLHttpRequest();\n\n    http_request.open('GET', json_uri);\n    http_request.onload = function(event)\n    {\n      if(this.status == 200)\n      {\n        var configuration = JSON.parse(http_request.response);\n\n        // We got some config entries\n        if(configuration.length)\n          this.addConfigs_byArray(configuration)\n\n        // Config was empty\n        else\n          dispatchError(errors.ERROR_REQUEST_EMPTY)\n      }\n\n      // Request returned an error\n      else\n        dispatchError(errors.ERROR_REQUEST_FAILURE)\n    };\n\n    // Connection error\n    http_request.onerror = function(event)\n    {\n      dispatchError(navigator.onLine ? errors.ERROR_NETWORK_UNKNOWN\n                                     : errors.ERROR_NETWORK_OFFLINE)\n    };\n\n    http_request.send();\n  };\n\n  this.addConfigs = function(configuration)\n  {\n    if(typeof configuration == 'string')\n      this.addConfigs_byUri(configuration)\n\n    else if(configuration instanceof Array)\n      this.addConfigs_byArray(configuration)\n\n    else\n      this.addConfigs_byObject(configuration)\n  };\n\n\n  // Add handshake servers configuration\n  if(handshake_servers)\n    this.addConfigs(handshake_servers)\n};\nHandshakeManager.prototype.__proto__   = Manager.prototype;\nHandshakeManager.prototype.constructor = HandshakeManager;\n\n\nmodule.exports = HandshakeManager;","var EventEmitter = require(\"events\").EventEmitter;\n\n\nfunction Manager()\n{\n  EventEmitter.call(this);\n\n  var self = this;\n\n\n  this._connectors = [];\n\n  this.__defineGetter__(\"status\", function()\n  {\n    return this._connectors.length ? 'connected' : 'disconnected';\n  });\n\n\n  this._initConnector = function(connector)\n  {\n    connector.on('open', function()\n    {\n      if(self.status == 'disconnected')\n         self.emit('connected');\n\n      self._connectors.push(connector);\n    });\n    connector.on('close', function()\n    {\n      self._connectors.splice(self._connectors.indexOf(connector), 1);\n    });\n    connector.on('error', function(error)\n    {\n      connector.close();\n\n      self.emit('error', error);\n    });\n\n    connector._messageUnpacked = function(message)\n    {\n      switch(message.type)\n      {\n        case 'offer':\n        case 'answer':\n          self.emit(message.type, message, connector);\n        break;\n\n        default:\n          console.error(\"Unknown message type '\"+type+\"'\");\n          console.error(message);\n      };\n    };\n\n    connector.on('message', function(message)\n    {\n      connector._messageUnpacked(messagepacker.unpack(message));\n    });\n  };\n\n\n  /**\n   * {Object} message - Message to be send\n   * {Connector} [incomingConnector] - {Connector} to don't send the message\n   */\n  this.send = function(message, incomingConnector)\n  {\n    for(var i=0, peer; peer=this._connectors[i]; i++)\n    {\n      // Don't send the message to the same connector where we received it\n      if(peer === incomingConnector)\n        continue;\n\n      peer.send(message);\n    };\n  };\n\n\n  /**\n   * Close all the connections\n   */\n  this.close = function()\n  {\n    for(var i=0, peer; peer=this._connectors[i]; i++)\n      peer.close();\n  };\n\n\n//  //\n//  // Connection request and response proccessors\n//  //\n//\n//  this._connectRequest = function(request)\n//  {\n//    var id  = request.id;\n//    var sdp = request.params[0];\n//\n//    var from = request.from;\n//\n//    // Check if it's a re-try\n//    var response = responses[from];\n//    if(response)\n//    {\n//      // Old message, ignore it\n//      if(response.id > id)\n//        return\n//\n//      // Updated message (or duplicated one), delete old response\n//      clearTimeout(response.timeout);\n//      delete responses[from];\n//\n//      // Duplicated message, re-send it\n//      if(response.id == id)\n//      {\n//        sendResponse(response.message, from)\n//        return\n//      }\n//    }\n//\n//    // It's not a re-try, notify about the connection request\n//    self.emit('offer', from, sdp, id)\n//  };\n//\n//  this._connectResponse = function(response)\n//  {\n//    var id     = response.id;\n//    var error  = response.error;\n//    var result = response.result;\n//\n//    var from = response.from;\n//\n//    var request_ids = requests[from];\n//    if(request_ids)\n//    {\n//      var request = request_ids[id];\n//      if(request)\n//         request.callback(error, result);\n//    }\n//  };\n//\n//\n//  /**\n//   * Send a request to try to connect to another peer\n//   */\n//  this._sendRequest = function(request, dest, callback)\n//  {\n//    // Store the response to prevent duplicates\n//    if(callback)\n//    {\n//      var id = request.id = HandshakeConnector.requestID++;\n//\n//      var request_ids = requests[dest] = requests[dest] || {};\n//\n//      var request_id = request_ids[id] =\n//      {\n//        request: request,\n//        callback: dispatchCallback,\n//        error_tries: 0\n//      };\n//\n//      function dispatchCallback(error, result)\n//      {\n//        clearTimeout(request_id.timeout);\n//\n//        delete request_ids[id];\n//        if(!Object.keys(request_ids).length)\n//          delete requests[dest];\n//\n//        callback(error, result);\n//      }\n//\n//      function dispatchRequest()\n//      {\n//        request_id.timeout = setTimeout(function()\n//        {\n//          request_id.error_tries++;\n//\n//          if(request_id.error_tries < HandshakeConnector.MAX_ALLOWED_ERROR_TRIES)\n//          {\n//            dispatchRequest();\n//            send(request, dest);\n//          }\n//\n//          // Max number of re-try achieved, raise error\n//          else\n//            dispatchCallback(new Error('Timed Out'))\n//        },\n//        HandshakeConnector.BASE_TIMEOUT * Math.pow(2, request_id.error_tries));\n//      }\n//\n//      dispatchRequest();\n//    }\n//\n//    // Send request\n//    send(request, dest);\n//  };\n//\n//  /**\n//   * Send a response to a peer trying to connect to us\n//   */\n//  function sendResponse(response, dest)\n//  {\n//    // Store the response to prevent duplicates\n//    responses[dest] = {message: response};\n//    responses[dest].timeout = setTimeout(function()\n//    {\n//      delete responses[dest];\n//    },\n//    HandshakeConnector.BASE_TIMEOUT * Math.pow(2, HandshakeConnector.MAX_ALLOWED_ERROR_TRIES));\n//\n//    // Send response\n//    send(response, dest);\n//  };\n};\nManager.prototype.__proto__   = EventEmitter.prototype;\nManager.prototype.constructor = Manager;\n\n\nmodule.exports = Manager;","var Manager = require('./Manager');\n\nvar Connector_DataChannel = require('../connectors/core/DataChannel');\n\n\n/**\n * @classdesc Manager of the communications with the other peers\n *\n * @constructor\n */\nfunction PeersManager(routingLabel)\n{\n  Manager.call(this);\n\n  var self = this;\n\n\n  function createConnector(channel)\n  {\n    var connector = new Connector_DataChannel(channel);\n\n    this._initConnector(connector);\n\n    return connector;\n  };\n\n\n  var peers = {};\n\n  this.add = function(sessionID, peerConnection)\n  {\n    peerConnection.addEventListener('signalingstatechange', function(event)\n    {\n      // Remove the peer from the list of peers when gets closed\n      if(peerConnection.signalingState == 'closed')\n        delete peers[sessionID];\n    });\n\n    // Routing DataChannel, just init routing functionality on it\n    var channels = peerConnection.getDataChannels();\n\n    for(var i=0, channel; channel=channels[i]; i++)\n      if(channel.label == routingLabel)\n        self._connectors.push(createConnector(channel));\n\n    // Add the PeerConnection to the list of enabled ones\n    peers[sessionID] = peerConnection;\n  };\n\n  this.get = function(sessionID)\n  {\n    return peers[sessionID];\n  };\n};\nPeersManager.prototype.__proto__   = Manager.prototype;\nPeersManager.prototype.constructor = PeersManager;\n\n\nmodule.exports = PeersManager;","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        throw TypeError('Uncaught, unspecified \"error\" event.');\n      }\n      return false;\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        len = arguments.length;\n        args = new Array(len - 1);\n        for (i = 1; i < len; i++)\n          args[i - 1] = arguments[i];\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    len = arguments.length;\n    args = new Array(len - 1);\n    for (i = 1; i < len; i++)\n      args[i - 1] = arguments[i];\n\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    var m;\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      console.trace();\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  var ret;\n  if (!emitter._events || !emitter._events[type])\n    ret = 0;\n  else if (isFunction(emitter._events[type]))\n    ret = 1;\n  else\n    ret = emitter._events[type].length;\n  return ret;\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n"]}