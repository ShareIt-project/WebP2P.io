{"version":3,"file":"bundle.js","sources":["../lib/index.js"],"names":["WebP2P","options","disconnected","self","status","dispatchEvent","Event","connectTo","uid","connector","labels","callback","createOffer","peer","peersManager","get","create","this","routingLabel","commonLabels","concat","label","i","channel","channels","createDataChannel","event","mediaConstraints","mandatory","OfferToReceiveAudio","OfferToReceiveVideo","offer","setLocalDescription","console","log","UUIDv4","b","a","Math","random","toString","replace","handshake_servers","stun_server","Object","defineProperty","value","__defineGetter__","handshakeManager","SyntaxError","HandshakeManager","Array","addConfigs_byArray","addConfigs_byUri","onconnected","event2","onpresence","from","error","connections","max_connections","close","onforward","forward","message","ondisconnected","document","createEvent","initEvent","onerror","PeersManager","window","addEventListener","prototype","__proto__","EventTarget","constructor","exports"],"mappings":"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","sourcesContent":["/**\n * @classdesc Init and connect to the WebP2P.io network\n *\n * @constructor\n */\nfunction WebP2P(options)\n{\n  var self = this;\n\n\n  /**\n   * UUID generator\n   */\n  var UUIDv4 = function b(a)\n  {\n    return a ? (a ^ Math.random() * 16 >> a / 4).toString(16) : ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, b);\n  };\n\n\n  var options = options || {};\n\n  // Internal options\n  var commonLabels      = options.commonLabels || [];\n  var handshake_servers = options.handshake_servers;\n  var stun_server       = options.stun_server || 'stun.l.google.com:19302';\n\n  // Read-only options\n  Object.defineProperty(this, \"routingLabel\",\n  {\n    value: options.routingLabel || \"webp2p\"\n  });\n  Object.defineProperty(this, \"uid\",\n  {\n    value: options.uid || UUIDv4()\n  });\n\n  this.__defineGetter__(\"status\", function()\n  {\n    if(peersManager.status == 'connected')\n      return 'connected'\n\n    return handshakeManager.status\n  });\n\n\n  function disconnected()\n  {\n    if(self.status == 'disconnected')\n      self.dispatchEvent(new Event('disconnected'));\n  }\n\n  function onerror(error)\n  {\n    console.error(error);\n  };\n\n\n  //\n  // Connection methods\n  //\n\n  /**\n   * Callback to send the offer. If not defined send it to all connected peers.\n   *\n   * @callback WebP2P~ConnectToCallback\n   * @param {Error} error\n   * @param {RTCPeerConnection} peer - The (newly created) peer.\n   */\n\n  /**\n   * Connects to another peer based on its UID. If we are already connected,\n   * it does nothing.\n   *\n   * @param {UUID} uid - Identifier of the other peer to be connected.\n   * @param {string[]} [labels] - Per-connection labels\n   * @param {WebP2P~ConnectToCallback} callback\n   */\n  this.connectTo = function(uid, labels, callback)\n  {\n    // Fix the optional parameters\n    if(typeof labels == 'function')\n    {\n      if(callback)\n        throw SyntaxError(\"Nothing can be defined after the callback\");\n\n      callback = options;\n      labels = [];\n    };\n\n    connectTo(uid, null, labels, callback);\n  };\n\n  /**\n   * Connects to another peer based on its UID. If we are already connected,\n   * it does nothing.\n   *\n   * @private\n   *\n   * @param {UUID} uid - Identifier of the other peer to be connected.\n   * @param {HandshakeConnector} connector - Optional connector where to\n   * @param {string[]} labels - Per-connection labels\n   * @param {WebP2P~ConnectToCallback} callback\n   */\n  function connectTo(uid, connector, labels, callback)\n  {\n    // Flag to check if we should create the offer or not\n    var createOffer = false;\n\n    // If peer is not currently connected, create a new one with a routing connector\n    var peer = peersManager.get(uid);\n    if(!peer)\n    {\n      createOffer = true;\n\n      // Create PeerConnection\n      peer = peersManager.create(uid, connector, this.routingLabel);\n    };\n\n    // Add the requested channels to be connected to the list of common ones for\n    // this PeerConnection\n    labels = commonLabels.concat(labels);\n\n    for(var i=0, label; label=labels[i]; i++)\n    {\n      // If channel doesn't exists, create and initialize it\n      var channel = peer.channels[label]\n      if(!channel)\n      {\n        createOffer = true;\n\n        // Create new DataChannel\n        peer.channels[label] = channel = peer.createDataChannel(label);\n\n        // Dispatch new DataChannel event to the application\n        var event = new Event('datachannel');\n            event.channel = channel;\n\n        peer.dispatchEvent(event);\n      };\n    };\n\n    // Connection characteristics changed, send offer to the other (new) peer\n    if(createOffer)\n    {\n      var mediaConstraints =\n      {\n        mandatory:\n        {\n          OfferToReceiveAudio: false,\n          OfferToReceiveVideo: false\n        }\n      };\n\n      peer.createOffer(function(offer)\n      {\n        // Set the peer local description\n        peer.setLocalDescription(offer,\n        function()\n        {\n          console.log(\"Generated Offer LocalDescription for UID \"+uid);\n\n          if(callback)\n             callback(null, peer);\n        },\n        callback);\n      },\n      callback,\n      mediaConstraints);\n    }\n\n    // Connection has not changed, just notify to the application\n    else if(callback)\n      callback(null, peer);\n  };\n\n  /**\n   * Process the offer to connect to a new peer\n   *\n   * @param {UUID}   uid - Identifier of the other peer.\n   * @param {string} sdp - Session Description Protocol data of the other peer.\n   *\n   * @return {RTCPeerConnection} The (newly created) peer.\n   */\n  function connectRequest(uid, sdp, connector)\n  {\n    console.log(\"Received connection request from \"+uid);\n\n    // Search the peer between the list of currently connected ones,\n    // or create it if it's not connected\n    var peer = peersManager.getOrCreate(uid, connector);\n\n    // Process offer\n    peer.setRemoteDescription(new RTCSessionDescription(\n    {\n      sdp: sdp,\n      type: 'offer'\n    }),\n    function()\n    {\n      // Send answer\n      peer.createAnswer(function(answer)\n      {\n        // Set the peer local description\n        peer.setLocalDescription(answer,\n        function()\n        {\n          console.log(\"Generated Answer LocalDescription for UID \"+uid);\n        },\n        onerror);\n      },\n      onerror)\n    },\n    onerror);\n  };\n\n  /**\n   * Process the answer received while attempting to connect to the other peer\n   *\n   * @param {UUID} uid - Identifier of the other peer.\n   * @param {String} sdp - Session Description Protocol data of the other peer.\n   */\n  function connectResponse(uid, sdp)\n  {\n    console.log(\"Received connection response from \"+uid);\n\n    // Search the peer on the list of currently connected ones\n    var peer = peersManager.get(uid);\n    if(peer)\n      peer.setRemoteDescription(new RTCSessionDescription(\n      {\n        sdp: sdp,\n        type: 'answer'\n      }),\n      function()\n      {\n        console.log(\"Successfuly generated RemoteDescription for UID \"+uid);\n      },\n      onerror);\n\n    else\n      onerror(\"Connection with peer '\" + uid + \"' was not previously requested\");\n  };\n\n\n  //\n  // Handshake manager\n  //\n\n  var handshakeManager = new HandshakeManager(this.uid);\n\n  if(handshake_servers)\n  {\n    if(handshake_servers instanceof Array)\n      handshakeManager.addConfigs_byArray(handshake_servers)\n    else\n      handshakeManager.addConfigs_byUri(handshake_servers)\n  };\n\n  handshakeManager.onconnected = function(event)\n  {\n    var connector = event.connector;\n\n    var event2 = new Event('connected');\n        event2.uid = self.uid;\n\n    self.dispatchEvent(event2);\n  };\n  handshakeManager.onpresence = function(event)\n  {\n    var from      = event.from;\n    var connector = event.connector;\n\n    connectTo(from, connector, [], function(error)\n    {\n      if(error)\n        console.error(from, connector, error);\n\n      else\n      {\n        // Increase the number of connections reached throught\n        // this handshake server\n        connector.connections++;\n\n        // Close connection with handshake server if we got its quota of peers\n        if(connector.connections == connector.max_connections)\n           connector.close();\n      }\n    });\n  };\n  handshakeManager.onforward = function(event)\n  {\n    peersManager.forward(event.message, event.connector);\n  };\n  handshakeManager.ondisconnected = function(event)\n  {\n    var event2 = document.createEvent(\"Event\");\n        event2.initEvent('handshakeManager.disconnected',true,true);\n        event2.handshakeManager = handshakeManager;\n\n    self.dispatchEvent(event2);\n\n    disconnected();\n  };\n  handshakeManager.onerror = function(error)\n  {\n    self.dispatchEvent(error);\n  };\n\n\n  //\n  // Peers manager\n  //\n\n  var peersManager = new PeersManager();\n\n  peersManager.onconnected = function(event)\n  {\n\n  };\n  peersManager.onforward = function(event)\n  {\n\n  };\n  peersManager.ondisconnected = function(event)\n  {\n\n  };\n  peersManager.onerror = function(error)\n  {\n    self.dispatchEvent(error);\n  };\n\n\n  //\n  // Clossing functions\n  //\n\n  this.close = function()\n  {\n    handshakeManager.close();\n    peersManager.close();\n  };\n\n  // Close all connections when user goes out of the page\n  if(window)\n    window.addEventListener('beforeunload', function(event)\n    {\n      self.close();\n    });\n};\nWebP2P.prototype.__proto__   = EventTarget.prototype;\nWebP2P.prototype.constructor = WebP2P;\n\n\nexports.WebP2P = WebP2P;"]}